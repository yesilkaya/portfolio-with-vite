1- require yerine import kullanÄ±lÄ±r
2- interface kullanÄ±lÄ±r
3- 


âš™ï¸ 1. ModÃ¼l Sistemi (Import/Require)
JavaScript	                    TypeScript
const http = require("http");	import http from "http";
CommonJS kullanÄ±r	            ESModules kullanÄ±r (modern, standart uyumlu)

âœ… AvantajÄ±:

TypeScript'in import sÃ¶zdizimi daha modern ve geleceÄŸe yÃ¶neliktir.

Otomatik tamamlama ve modÃ¼l baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ±n doÄŸru Ã§Ã¶zÃ¼lmesi kolaylaÅŸÄ±r.

TarayÄ±cÄ±da (ESM destekleyen ortamda) doÄŸrudan Ã§alÄ±ÅŸtÄ±rmak daha kolaydÄ±r.

ğŸ§¾ 2. Tip GÃ¼venliÄŸi (Types vs. No Types)
JavaScript	    TypeScript
Dinamik tipler	IncomingMessage, ServerResponse, Record<string, string> gibi tipler kullanÄ±r

âœ… AvantajÄ±:

HatalarÄ± yazÄ±m anÄ±nda yakalar (Ã¶rneÄŸin yanlÄ±ÅŸ veri tipi ile iÅŸlem yapÄ±ldÄ±ÄŸÄ±nda).

Otomatik tamamlama (IntelliSense) saÄŸlar.

Kodun kendisi bir belge gibidir: hangi yapÄ± ne bekliyor aÃ§Ä±kÃ§a bellidir.

BÃ¼yÃ¼k ekiplerle Ã§alÄ±ÅŸÄ±rken anlaÅŸÄ±lÄ±r ve gÃ¼venilir kod Ã¼retimi saÄŸlar.

ğŸ“ 3. KÃ¶k Dizin TanÄ±mÄ±: __dirname vs process.cwd()
JavaScript	TypeScript
__dirname	process.cwd()

âœ… AvantajÄ±:

process.cwd() Ã§alÄ±ÅŸma dizinine gÃ¶re yol Ã§Ã¶zer. Ã–zellikle TypeScript'te .ts derleme sonrasÄ± dosya yapÄ±sÄ± deÄŸiÅŸtiÄŸinde daha gÃ¼venlidir.

Dosya yollarÄ± daha kolay yÃ¶netilir, karmaÅŸa azalÄ±r.

ğŸ“¥ 4. JSON Verisini Tipli Kullanmak
JavaScript	TypeScript
const data = JSON.parse(body);	const data = JSON.parse(body) as { firstName: string; lastName: string; email: string; message: string };

âœ… AvantajÄ±:

TypeScriptâ€™te JSON yapÄ±sÄ±na Ã¶zel tip tanÄ±mlamak, hatalarÄ± engeller.

GeliÅŸtirici olarak hangi alanlarÄ±n geldiÄŸini gÃ¶rÃ¼rsÃ¼n.

Daha sÃ¼rdÃ¼rÃ¼lebilir ve okunabilir hale gelir.

ğŸ“š 5. Tipli Koleksiyon KullanÄ±mÄ±
JavaScript	TypeScript
let jsonArray = [];	let jsonArray: Array<Record<string, string>> = [];

âœ… AvantajÄ±:

Dizide hangi veri yapÄ±sÄ±nÄ±n bulunduÄŸu bellidir.

Dizi Ã¼zerinde iÅŸlem yaparken (map, filter vb.) otomatik tamamlama ve tip denetimi yapÄ±lÄ±r.

ğŸ“œ 6. Kod HatalarÄ±nÄ± Ã–nleme (Compile-Time Checks)
âœ… TypeScriptâ€™in en Ã¶nemli avantajÄ± burada:

Derleme (compile) sÄ±rasÄ±nda yazÄ±m ve mantÄ±k hatalarÄ±nÄ± yakalayabilir.

Ã–rneÄŸin: message.toUppercase() (yanlÄ±ÅŸ yazÄ±m) gibi hatalarÄ± JavaScript runtimeâ€™da fark edersin ama TypeScript derlemede seni uyarÄ±r.

ğŸ”’ 7. Daha GÃ¼Ã§lÃ¼ EditÃ¶r DesteÄŸi
âœ… TypeScript ile avantajlÄ±sÄ±n Ã§Ã¼nkÃ¼:

VS Code gibi editÃ¶rlerde hatalar anÄ±nda gÃ¶rÃ¼nÃ¼r.

Otomatik tamamlama, belgeleme (hover docs), yÃ¶nlendirme (go to definition) gibi araÃ§lar daha etkili Ã§alÄ±ÅŸÄ±r.


| Ã–zellik                            | JavaScript           | TypeScript                       | Avantaj (TypeScript)        |
| ---------------------------------- | -------------------- | -------------------------------- | --------------------------- |
| ModÃ¼l sistemi                      | CommonJS (`require`) | ESModules (`import`)             | Modern ve taÅŸÄ±nabilir       |
| Tip tanÄ±mÄ±                         | Yok                  | Var (`interface`, `Record`, vs.) | GÃ¼venli, belgeli kod        |
| Derleme Ã¶ncesi hata kontrolÃ¼       | Yok                  | Var                              | Hatalar erkenden yakalanÄ±r  |
| Otomatik tamamlama ve IntelliSense | SÄ±nÄ±rlÄ±              | Tam destek                       | Verimlilik artar            |
| JSON verisiyle Ã§alÄ±ÅŸma             | Tip kontrolsÃ¼z       | Tip gÃ¼venli                      | YanlÄ±ÅŸ veri formatÄ± Ã¶nlenir |
| Kod okunabilirliÄŸi                 | Orta                 | YÃ¼ksek                           | AnlaÅŸÄ±lÄ±r yapÄ±              |
| Refactoring kolaylÄ±ÄŸÄ±              | Zor                  | Kolay                            | Daha az hata riski          |
